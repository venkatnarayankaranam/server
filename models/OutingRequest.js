const mongoose = require('mongoose');
const QRCode = require('qrcode');

const outingRequestSchema = new mongoose.Schema({
  studentId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
  },
  outingDate: {
    type: Date,
    required: true
  },
  outingTime: {
    type: String,
    required: true
  },
  returnTime: {
    type: String,
    required: true
  },
  returnDate: {
    type: Date,
    default: function() {
      return this.outingDate;
    }
  },
  purpose: {
    type: String,
    required: true
  },
  parentPhoneNumber: {
    type: String,
    required: true,
  },
  hostelBlock: {
    type: String,
    required: true,
  },
  floor: {
    type: String,
    required: true,
    get: function(v) {
      return v; // Return the original value without transformation
    }
  },
  // Update approval status fields
  status: {
    type: String,
    enum: ['pending', 'approved', 'denied'],
    default: 'pending'
  },
  currentLevel: {
    type: String,
    enum: ['floor-incharge', 'hostel-incharge', 'warden', 'completed'],
    default: 'floor-incharge'
  },
  approvalFlags: {
    floorIncharge: {
      isApproved: { type: Boolean, default: false },
      timestamp: Date,
      remarks: String
    },
    hostelIncharge: {
      isApproved: { type: Boolean, default: false },
      timestamp: Date,
      remarks: String
    },
    warden: {
      isApproved: { type: Boolean, default: false },
      timestamp: Date,
      remarks: String
    }
  },
  approvalFlow: [{
    level: String,
    status: {
      type: String,
      enum: ['pending', 'approved', 'denied'],
      default: 'pending'
    },
    timestamp: Date,
    remarks: String,
    approvedBy: String,
    approverInfo: {
      email: String,
      role: String
    }
  }],
  createdAt: {
    type: Date,
    default: Date.now,
  },
  qrCode: {
    outgoing: {
      data: String,
      generatedAt: Date,
      isExpired: { type: Boolean, default: false },
      scannedAt: Date,
      scannedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
      },
      validUntil: Date,
      qrId: String // Unique identifier for this QR
    },
    incoming: {
      data: String,
      generatedAt: Date,
      isExpired: { type: Boolean, default: false },
      scannedAt: Date,
      scannedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
      },
      validUntil: Date,
      qrId: String, // Unique identifier for this QR
      autoGeneratedAt: Date // When incoming QR was auto-generated
    }
  },
  gateActivity: [{
    type: { type: String, enum: ['OUT', 'IN'] },
    scannedAt: Date,
    scannedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    qrType: { type: String, enum: ['outgoing', 'incoming'] },
    location: String,
    remarks: String
  }]
});

// Add TTL index to expire checkIn and checkOut after 24 hours
outingRequestSchema.index({ 'checkIn.time': 1 }, { expireAfterSeconds: 86400 });
outingRequestSchema.index({ 'checkOut.time': 1 }, { expireAfterSeconds: 86400 });

// Add indexes for better query performance
outingRequestSchema.index({ currentLevel: 1 });
outingRequestSchema.index({ 'approvalFlow.userId': 1 });
outingRequestSchema.index({ hostelBlock: 1, floor: 1 });

// Add static methods to help with querying
outingRequestSchema.statics.findForFloorIncharge = function(userId, hostelBlock, floor) {
  return this.find({
    $or: [
      {
        currentLevel: 'floor-incharge',
        hostelBlock: hostelBlock,
        floor: this.normalizeFloor(floor)
      },
      {
        'approvalFlow.userId': userId
      }
    ]
  }).populate('studentId').sort({ createdAt: -1 });
};

outingRequestSchema.statics.findForHostelIncharge = function(userId, hostelBlock) {
  return this.find({
    $or: [
      {
        currentLevel: 'hostel-incharge',
        hostelBlock: hostelBlock
      },
      {
        'approvalFlow.userId': userId
      }
    ]
  }).populate('studentId').sort({ createdAt: -1 });
};

outingRequestSchema.statics.findForWarden = function(userId) {
  return this.find({
    $or: [
      { currentLevel: 'warden' },
      { 'approvalFlow.userId': userId }
    ]
  }).populate('studentId').sort({ createdAt: -1 });
};

outingRequestSchema.methods.validateNextApprover = function(approverRole) {
  const approvalSequence = ['floor-incharge', 'hostel-incharge', 'warden'];
  const currentIndex = approvalSequence.indexOf(this.currentLevel);
  const approverIndex = approvalSequence.indexOf(approverRole);

  if (currentIndex === -1 || approverIndex === -1) {
    throw new Error('Invalid approval level');
  }

  if (approverIndex !== currentIndex) {
    throw new Error(`Invalid approval sequence. Expected ${this.currentLevel}, got ${approverRole}`);
  }

  // Check for prerequisite approvals
  if (approverRole === 'hostel-incharge' && this.floorInchargeApproval !== 'approved') {
    throw new Error('Floor Incharge approval required first');
  }
  
  if (approverRole === 'warden' && this.hostelInchargeApproval !== 'approved') {
    throw new Error('Hostel Incharge approval required first');
  }

  return true;
};

outingRequestSchema.methods.validateApprovalFlow = function(approvalEntry) {
  const validRoles = ['floor-incharge', 'hostel-incharge', 'warden', 'FloorIncharge', 'HostelIncharge', 'Warden'];
  const validLevels = ['1', '2', '3', 'floor-incharge', 'hostel-incharge', 'warden'];

  const missingFields = [];
  if (!approvalEntry.level) missingFields.push('level');
  if (!approvalEntry.status) missingFields.push('status');
  if (!approvalEntry.approvedBy) missingFields.push('approvedBy');
  if (!approvalEntry.approverInfo?.email) missingFields.push('approverInfo.email');
  if (!approvalEntry.approverInfo?.role) missingFields.push('approverInfo.role');

  if (missingFields.length > 0) {
    throw new Error(`Missing required approval fields: ${missingFields.join(', ')}`);
  }

  // Validate level
  if (!validLevels.includes(String(approvalEntry.level))) {
    throw new Error(`Invalid level: ${approvalEntry.level}. Must be one of: ${validLevels.join(', ')}`);
  }

  // Validate role
  if (!validRoles.includes(approvalEntry.approverInfo.role)) {
    throw new Error(`Invalid role: ${approvalEntry.approverInfo.role}. Must be one of: ${validRoles.join(', ')}`);
  }

  // Validate approval sequence
  try {
    this.validateApprovalSequence(approvalEntry);
  } catch (error) {
    throw new Error(`Invalid approval sequence: ${error.message}`);
  }

  return true;
};

outingRequestSchema.methods.validateApprovalSequence = function(newApproval) {
  // Define approval levels and their order
  const workflowLevels = {
    'floor-incharge': 1,
    'hostel-incharge': 2,
    'warden': 3,
    '1': 1,
    '2': 2,
    '3': 3
  };

  const getLevel = (level) => workflowLevels[String(level)] || 0;
  const newLevel = getLevel(newApproval.level);

  // Log validation context
  console.log('Validating approval:', {
    newApproval,
    currentLevel: this.currentLevel,
    existingApprovals: this.approvalFlow?.map(a => ({
      level: a.level,
      status: a.status
    }))
  });

  // Basic validation
  if (!newLevel) {
    throw new Error(`Invalid approval level: ${newApproval.level}`);
  }

  const existingApprovals = this.approvalFlow || [];
  
  // First approval must be from floor incharge
  if (existingApprovals.length === 0 && newLevel !== 1) {
    throw new Error('First approval must be from Floor Incharge');
  }

  // Get last valid approval
  const lastValidApproval = [...existingApprovals]
    .reverse()
    .find(a => a.status === 'approved');

  // Ensure proper sequence
  if (lastValidApproval) {
    const lastLevel = getLevel(lastValidApproval.level);
    
    // Allow same level approvals for current level
    if (newLevel === getLevel(this.currentLevel)) {
      return true;
    }

    // Check sequence
    if (newLevel !== lastLevel + 1) {
      throw new Error(
        `Invalid approval sequence: Expected level ${lastLevel + 1}, got ${newLevel}`
      );
    }
  }

  return true;
};

outingRequestSchema.pre('save', function(next) {
  try {
    if (this.isModified('approvalFlow') && this.approvalFlow?.length > 0) {
      // Get latest approval
      const latestApproval = this.approvalFlow[this.approvalFlow.length - 1];
      
      // Update approvalFlags and currentLevel/status based on approval
      if (latestApproval.status === 'approved') {
        const level = String(latestApproval.level);
        switch (level) {
          case '1':
          case 'floor-incharge':
            this.approvalFlags.floorIncharge.isApproved = true;
            this.approvalFlags.floorIncharge.timestamp = latestApproval.timestamp || new Date();
            this.approvalFlags.floorIncharge.remarks = latestApproval.remarks || '';
            if (this.currentLevel === 'floor-incharge') {
              this.currentLevel = 'hostel-incharge';
            }
            break;
          case '2':
          case 'hostel-incharge':
            this.approvalFlags.hostelIncharge.isApproved = true;
            this.approvalFlags.hostelIncharge.timestamp = latestApproval.timestamp || new Date();
            this.approvalFlags.hostelIncharge.remarks = latestApproval.remarks || '';
            if (this.currentLevel === 'hostel-incharge') {
              this.currentLevel = 'warden';
            }
            break;
          case '3':
          case 'warden':
            this.approvalFlags.warden.isApproved = true;
            this.approvalFlags.warden.timestamp = latestApproval.timestamp || new Date();
            this.approvalFlags.warden.remarks = latestApproval.remarks || '';
            if (this.currentLevel === 'warden') {
              this.currentLevel = 'completed';
              this.status = 'approved';
            }
            break;
        }
      }
    }
    next();
  } catch (error) {
    next(error);
  }
});

// Update the pre-save middleware for approval sequence validation
outingRequestSchema.pre('save', function(next) {
  try {
    if (this.isModified('approvalFlow')) {
      // Skip sequence validation for initial floor incharge approval
      if (this.approvalFlow.length === 1 && 
          (this.approvalFlow[0].level === 'floor-incharge' || 
           this.approvalFlow[0].level === '1')) {
        return next();
      }

      // Map numeric levels to string levels for validation
      const levelMap = {
        '1': 'floor-incharge',
        '2': 'hostel-incharge',
        '3': 'warden',
        'floor-incharge': 'floor-incharge',
        'hostel-incharge': 'hostel-incharge',
        'warden': 'warden'
      };

      const approvalOrder = ['floor-incharge', 'hostel-incharge', 'warden'];

      // Validate approval sequence
      if (this.approvalFlow.length > 1) {
        let lastValidLevel = null;
        
        for (const approval of this.approvalFlow) {
          const currentLevel = levelMap[String(approval.level)];
          
          if (!currentLevel) {
            throw new Error(`Invalid approval level: ${approval.level}`);
          }

          const currentIndex = approvalOrder.indexOf(currentLevel);
          
          if (lastValidLevel) {
            const lastIndex = approvalOrder.indexOf(lastValidLevel);
            
            // Allow same level approvals for floor incharge
            if (currentLevel === 'floor-incharge' && lastValidLevel === 'floor-incharge') {
              continue;
            }
            
            // Ensure proper sequence for other levels
            if (currentIndex <= lastIndex && currentLevel !== lastValidLevel) {
              throw new Error(`Invalid approval sequence: ${lastValidLevel} -> ${currentLevel}`);
            }
          }

          lastValidLevel = currentLevel;
        }
      }
    }
    next();
  } catch (error) {
    next(error);
  }
});

outingRequestSchema.methods.moveToNextLevel = function() {
  const workflow = {
    'floor-incharge': 'hostel-incharge',
    'hostel-incharge': 'warden',
    'warden': 'completed'
  };

  // Update current level
  const nextLevel = workflow[this.currentLevel];
  if (nextLevel) {
    this.currentLevel = nextLevel;
  }

  // Only update status to approved if all approvals are complete
  if (this.checkAllApprovals()) {
    this.status = 'approved';
    this.currentLevel = 'completed';
  }

  return this;
};

outingRequestSchema.methods.checkAllApprovals = function() {
  return (
    this.approvalFlags.floorIncharge.isApproved &&
    this.approvalFlags.hostelIncharge.isApproved &&
    this.approvalFlags.warden.isApproved
  );
};

// Add method to handle approvals
outingRequestSchema.methods.handleApproval = function(role, remarks = '') {
  const approvalKey = role.replace('-', '');
  
  // Set approval flag for current role
  this.approvalFlags[approvalKey] = {
    isApproved: true,
    timestamp: new Date(),
    remarks: remarks
  };

  // Move to next level but don't automatically approve
  this.moveToNextLevel();
};

outingRequestSchema.pre('save', function(next) {
  if (this.approvalFlow?.length > 0) {
    const uniqueApprovals = [];
    const seen = new Set();
    
    this.approvalFlow.forEach(approval => {
      const key = `${approval.approverInfo?.email}-${approval.level}`;
      if (!seen.has(key)) {
        seen.add(key);
        uniqueApprovals.push(approval);
      }
    });
    
    this.approvalFlow = uniqueApprovals;
  }
  next();
});

outingRequestSchema.methods.canApprove = function(userRole) {
  try {
    const approvalSequence = ['floor-incharge', 'hostel-incharge', 'warden'];
    const currentIndex = approvalSequence.indexOf(this.currentLevel);
    const userIndex = approvalSequence.indexOf(userRole);

    if (currentIndex === -1 || userIndex === -1) {
      throw new Error('Invalid approval role');
    }

    // Check if this is the correct level for approval
    if (currentIndex !== userIndex) {
      throw new Error(`Invalid approval sequence. Expected ${this.currentLevel}, got ${userRole}`);
    }

    // For levels after floor-incharge, check previous approval
    if (userIndex > 0) {
      const previousRole = approvalSequence[userIndex - 1];
      const hasPreRequisiteApproval = this.approvalFlow.some(
        approval => approval.level === previousRole && approval.status === 'approved'
      );

      if (!hasPreRequisiteApproval) {
        throw new Error(`Missing prerequisite approval from ${previousRole}`);
      }
    }

    return true;
  } catch (error) {
    console.error('Approval validation error:', error);
    throw error;
  }
};

outingRequestSchema.methods.validateApproval = function(approvalData) {
  const { level, approverInfo } = approvalData;
  
  if (!level || !approverInfo?.email || !approverInfo?.role) {
    throw new Error('Missing required approval information');
  }
  
  return true;
};

outingRequestSchema.pre('save', async function(next) {
  try {
    // Validate required fields
    if (!this.studentId || !this.outingDate || !this.outingTime || !this.returnTime) {
      throw new Error('Missing required fields');
    }

    // Set returnDate to outingDate if not provided
    if (!this.returnDate) {
      this.returnDate = this.outingDate;
    }

    // Ensure approval flags exist
    if (!this.approvalFlags) {
      this.approvalFlags = {
        floorIncharge: { isApproved: false },
        hostelIncharge: { isApproved: false },
        warden: { isApproved: false }
      };
    }

    next();
  } catch (error) {
    next(error);
  }
});

// Generate outgoing QR code with student details
outingRequestSchema.methods.generateOutgoingQR = async function() {
  if (!this.checkAllApprovals()) {
    throw new Error('All approvals required before generating QR code');
  }

  // Populate student details if not already populated
  if (!this.studentId.name) {
    await this.populate('studentId');
  }

  const qrId = `OUT_${this._id}_${Date.now()}`;
  
  // Handle date conversion properly
  const dateStr = this.outingDate instanceof Date 
    ? this.outingDate.toISOString().split('T')[0] 
    : this.outingDate;
  
  const validUntil = new Date(dateStr + ' ' + this.outingTime);
  if (isNaN(validUntil.getTime())) {
    throw new Error(`Invalid date/time format: ${dateStr} ${this.outingTime}`);
  }
  validUntil.setHours(validUntil.getHours() + 2); // Valid for 2 hours after outing time

  const qrData = {
    requestId: this._id.toString(),
    qrId: qrId,
    type: 'OUTGOING',
    student: {
      id: this.studentId._id.toString(),
      name: this.studentId.name,
      rollNumber: this.studentId.rollNumber,
      hostelBlock: this.hostelBlock,
      floor: this.floor,
      roomNumber: this.studentId.roomNumber,
      phoneNumber: this.studentId.phoneNumber,
      parentPhoneNumber: this.parentPhoneNumber
    },
    outing: {
      date: this.outingDate,
      outingTime: this.outingTime,
      returnTime: this.returnTime,
      purpose: this.purpose
    },
    approvals: {
      floorIncharge: this.approvalFlags.floorIncharge.approvedBy,
      hostelIncharge: this.approvalFlags.hostelIncharge.approvedBy,
      warden: this.approvalFlags.warden.approvedBy
    },
    generatedAt: new Date().toISOString(),
    validUntil: validUntil.toISOString()
  };

  try {
    const qrCodeData = await QRCode.toDataURL(JSON.stringify(qrData));
    
    this.qrCode.outgoing = {
      data: qrCodeData,
      generatedAt: new Date(),
      isExpired: false,
      validUntil: validUntil,
      qrId: qrId
    };

    // Don't save here - let the caller handle saving to avoid conflicts
    return qrCodeData;
  } catch (error) {
    throw new Error(`Failed to generate outgoing QR code: ${error.message}`);
  }
};

// Generate incoming QR code (should be called 30 minutes before return time)
outingRequestSchema.methods.generateIncomingQR = async function() {
  // Populate student details if not already populated
  if (!this.studentId.name) {
    await this.populate('studentId');
  }

  const qrId = `IN_${this._id}_${Date.now()}`;
  
  // Handle date conversion properly
  const dateStr = this.outingDate instanceof Date 
    ? this.outingDate.toISOString().split('T')[0] 
    : this.outingDate;
  
  const returnDateTime = new Date(dateStr + ' ' + this.returnTime);
  if (isNaN(returnDateTime.getTime())) {
    throw new Error(`Invalid return date/time format: ${dateStr} ${this.returnTime}`);
  }
  
  const validUntil = new Date(returnDateTime.getTime() + (2 * 60 * 60 * 1000)); // Valid for 2 hours after return time

  const qrData = {
    requestId: this._id.toString(),
    qrId: qrId,
    type: 'INCOMING',
    student: {
      id: this.studentId._id.toString(),
      name: this.studentId.name,
      rollNumber: this.studentId.rollNumber,
      hostelBlock: this.hostelBlock,
      floor: this.floor,
      roomNumber: this.studentId.roomNumber,
      phoneNumber: this.studentId.phoneNumber,
      parentPhoneNumber: this.parentPhoneNumber
    },
    outing: {
      date: this.outingDate,
      outingTime: this.outingTime,
      returnTime: this.returnTime,
      purpose: this.purpose
    },
    generatedAt: new Date().toISOString(),
    validUntil: validUntil.toISOString()
  };

  try {
    const qrCodeData = await QRCode.toDataURL(JSON.stringify(qrData));
    
    this.qrCode.incoming = {
      data: qrCodeData,
      generatedAt: new Date(),
      autoGeneratedAt: new Date(),
      isExpired: false,
      validUntil: validUntil,
      qrId: qrId
    };

    // Don't save here - let the caller handle saving to avoid conflicts
    return qrCodeData;
  } catch (error) {
    throw new Error(`Failed to generate incoming QR code: ${error.message}`);
  }
};

// Legacy method for backward compatibility
outingRequestSchema.methods.generateApprovalQR = async function() {
  return await this.generateOutgoingQR();
};

// Method to scan QR code at gate
outingRequestSchema.methods.scanQR = async function(qrId, scannedBy, location = 'Main Gate') {
  try {
    let scanType = '';
    let qrType = '';
    
    // Determine which QR code was scanned
    if (this.qrCode.outgoing?.qrId === qrId) {
      // Outgoing QR scanned
      if (this.qrCode.outgoing.isExpired) {
        throw new Error('This QR code has already been used and is expired');
      }
      
      const now = new Date();
      if (now > this.qrCode.outgoing.validUntil) {
        throw new Error('This QR code has expired');
      }
      
      // Mark outgoing QR as expired
      this.qrCode.outgoing.isExpired = true;
      this.qrCode.outgoing.scannedAt = now;
      this.qrCode.outgoing.scannedBy = scannedBy;
      
      scanType = 'OUT';
      qrType = 'outgoing';
      
      // Auto-generate incoming QR 30 minutes before return time
      const dateStr = this.outingDate instanceof Date 
        ? this.outingDate.toISOString().split('T')[0] 
        : this.outingDate;
      const returnDateTime = new Date(dateStr + ' ' + this.returnTime);
      const generateIncomingAt = new Date(returnDateTime.getTime() - (30 * 60 * 1000));
      
      // If it's already time to generate incoming QR, generate it now
      if (now >= generateIncomingAt) {
        await this.generateIncomingQR();
      }
      
    } else if (this.qrCode.incoming?.qrId === qrId) {
      // Incoming QR scanned
      if (this.qrCode.incoming.isExpired) {
        throw new Error('This QR code has already been used and is expired');
      }
      
      const now = new Date();
      if (now > this.qrCode.incoming.validUntil) {
        throw new Error('This QR code has expired');
      }
      
      // Mark incoming QR as expired
      this.qrCode.incoming.isExpired = true;
      this.qrCode.incoming.scannedAt = now;
      this.qrCode.incoming.scannedBy = scannedBy;
      
      scanType = 'IN';
      qrType = 'incoming';
      
    } else {
      throw new Error('Invalid QR code for this request');
    }
    
    // Add to gate activity log
    this.gateActivity.push({
      type: scanType,
      scannedAt: new Date(),
      scannedBy: scannedBy,
      qrType: qrType,
      location: location,
      remarks: `Student ${scanType === 'OUT' ? 'exited' : 'entered'} hostel`
    });
    
    await this.save();
    
    return {
      success: true,
      type: scanType,
      student: await this.studentId,
      scanTime: new Date(),
      message: `Student ${scanType === 'OUT' ? 'exit' : 'entry'} recorded successfully`
    };
    
  } catch (error) {
    throw error;
  }
};

// Static method to find request by QR ID
outingRequestSchema.statics.findByQRId = async function(qrId) {
  const request = await this.findOne({
    $or: [
      { 'qrCode.outgoing.qrId': qrId },
      { 'qrCode.incoming.qrId': qrId }
    ]
  }).populate('studentId', 'name rollNumber hostelBlock floor roomNumber phoneNumber parentPhoneNumber branch semester');
  
  return request;
};

// Disabled: QR generation is now handled manually in routes to avoid conflicts
// outingRequestSchema.pre('save', async function(next) {
//   try {
//     // Only generate QR if status just changed to approved and QR doesn't exist
//     if (this.status === 'approved' && this.checkAllApprovals() && !this.qrCode?.outgoing?.data) {
//       await this.generateApprovalQR();
//     }
//     next();
//   } catch (error) {
//     next(error);
//   }
// });

module.exports = mongoose.model('OutingRequest', outingRequestSchema);

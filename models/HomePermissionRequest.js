const mongoose = require('mongoose');
const QRCode = require('qrcode');

const homePermissionRequestSchema = new mongoose.Schema({
  studentId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Student',
    required: true,
  },
  goingDate: {
    type: Date,
    required: true
  },
  incomingDate: {
    type: Date,
    required: true
  },
  homeTownName: {
    type: String,
    required: true
  },
  purpose: {
    type: String,
    required: true
  },
  category: {
    type: String,
    enum: ['normal', 'emergency'],
    default: 'normal'
  },
  parentPhoneNumber: {
    type: String,
    required: true,
  },
  hostelBlock: {
    type: String,
    required: true,
  },
  floor: {
    type: String,
    required: true,
    get: function(v) {
      return v; // Return the original value without transformation
    }
  },
  // Update approval status fields
  status: {
    type: String,
    enum: ['pending', 'approved', 'denied'],
    default: 'pending'
  },
  currentLevel: {
    type: String,
    enum: ['floor-incharge', 'hostel-incharge', 'warden', 'completed'],
    // No default - will be set based on category in pre-save middleware
  },
  approvalFlags: {
    floorIncharge: {
      isApproved: { type: Boolean, default: false },
      timestamp: Date,
      remarks: String
    },
    hostelIncharge: {
      isApproved: { type: Boolean, default: false },
      timestamp: Date,
      remarks: String
    },
    warden: {
      isApproved: { type: Boolean, default: false },
      timestamp: Date,
      remarks: String
    }
  },
  approvalFlow: [{
    level: String,
    status: {
      type: String,
      enum: ['pending', 'approved', 'denied'],
      default: 'pending'
    },
    timestamp: Date,
    remarks: String,
    approvedBy: String,
    approverInfo: {
      email: String,
      role: String
    }
  }],
  createdAt: {
    type: Date,
    default: Date.now,
  },
  qrCode: {
    outgoing: {
      data: String,
      generatedAt: Date,
      isExpired: { type: Boolean, default: false },
      scannedAt: Date,
      scannedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
      },
      validUntil: Date,
      qrId: String // Unique identifier for this QR
    },
    incoming: {
      data: String,
      generatedAt: Date,
      isExpired: { type: Boolean, default: false },
      scannedAt: Date,
      scannedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
      },
      validUntil: Date,
      qrId: String, // Unique identifier for this QR
      autoGeneratedAt: Date // When incoming QR was auto-generated
    }
  },
  gateActivity: [{
    type: { type: String, enum: ['OUT', 'IN'] },
    scannedAt: Date,
    scannedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    qrType: { type: String, enum: ['outgoing', 'incoming'] },
    location: String,
    remarks: String,
    isSuspicious: { type: Boolean, default: false },
    suspiciousComment: String,
    securityComment: String
  }]
});

// Add TTL index to expire checkIn and checkOut after 24 hours
homePermissionRequestSchema.index({ 'checkIn.time': 1 }, { expireAfterSeconds: 86400 });
homePermissionRequestSchema.index({ 'checkOut.time': 1 }, { expireAfterSeconds: 86400 });

// Add indexes for better query performance
homePermissionRequestSchema.index({ currentLevel: 1 });
homePermissionRequestSchema.index({ 'approvalFlow.userId': 1 });
homePermissionRequestSchema.index({ hostelBlock: 1, floor: 1 });

// Add static methods to help with querying
homePermissionRequestSchema.statics.findForFloorIncharge = function(userId, hostelBlock, floor) {
  return this.find({
    $or: [
      {
        currentLevel: 'floor-incharge',
        hostelBlock: hostelBlock,
        floor: this.normalizeFloor(floor)
      },
      {
        'approvalFlow.userId': userId
      }
    ]
  }).populate('studentId').sort({ createdAt: -1 });
};

homePermissionRequestSchema.statics.findForHostelIncharge = function(userId, hostelBlock) {
  return this.find({
    $or: [
      {
        currentLevel: 'hostel-incharge',
        hostelBlock: hostelBlock
      },
      {
        'approvalFlow.userId': userId
      }
    ]
  }).populate('studentId').sort({ createdAt: -1 });
};

homePermissionRequestSchema.statics.findForWarden = function(userId) {
  return this.find({
    $or: [
      { currentLevel: 'warden' },
      { 'approvalFlow.userId': userId }
    ]
  }).populate('studentId').sort({ createdAt: -1 });
};

homePermissionRequestSchema.statics.findByQRId = async function(qrId) {
  return this.findOne({
    $or: [
      { 'qrCode.outgoing.qrId': qrId },
      { 'qrCode.incoming.qrId': qrId }
    ]
  }).populate('studentId', 'name rollNumber hostelBlock floor roomNumber phoneNumber parentPhoneNumber branch semester');
};

homePermissionRequestSchema.methods.validateApprovalFlow = function(approvalEntry) {
  const validRoles = ['floor-incharge', 'hostel-incharge', 'warden', 'FloorIncharge', 'HostelIncharge', 'Warden'];
  const validLevels = ['1', '2', '3', 'floor-incharge', 'hostel-incharge', 'warden'];

  const missingFields = [];
  if (!approvalEntry.level) missingFields.push('level');
  if (!approvalEntry.status) missingFields.push('status');
  if (!approvalEntry.approvedBy) missingFields.push('approvedBy');
  if (!approvalEntry.approverInfo?.email) missingFields.push('approverInfo.email');
  if (!approvalEntry.approverInfo?.role) missingFields.push('approverInfo.role');

  if (missingFields.length > 0) {
    throw new Error(`Missing required approval fields: ${missingFields.join(', ')}`);
  }

  // Validate level
  if (!validLevels.includes(String(approvalEntry.level))) {
    throw new Error(`Invalid level: ${approvalEntry.level}. Must be one of: ${validLevels.join(', ')}`);
  }

  // Validate role
  if (!validRoles.includes(approvalEntry.approverInfo.role)) {
    throw new Error(`Invalid role: ${approvalEntry.approverInfo.role}. Must be one of: ${validRoles.join(', ')}`);
  }

  // Validate approval sequence
  try {
    this.validateApprovalSequence(approvalEntry);
  } catch (error) {
    throw new Error(`Invalid approval sequence: ${error.message}`);
  }

  return true;
};

homePermissionRequestSchema.methods.validateApprovalSequence = function(newApproval) {
  // Define approval levels and their order
  const workflowLevels = {
    'floor-incharge': 1,
    'hostel-incharge': 2,
    'warden': 3,
    '1': 1,
    '2': 2,
    '3': 3
  };

  const getLevel = (level) => workflowLevels[String(level)] || 0;
  const newLevel = getLevel(newApproval.level);

  // Log validation context
  console.log('Validating home permission approval:', {
    newApproval,
    currentLevel: this.currentLevel,
    existingApprovals: this.approvalFlow?.map(a => ({
      level: a.level,
      status: a.status
    }))
  });

  // Basic validation
  if (!newLevel) {
    throw new Error(`Invalid approval level: ${newApproval.level}`);
  }

  const existingApprovals = this.approvalFlow || [];
  
  // First approval validation - handle emergency requests
  if (existingApprovals.length === 0) {
    if (this.category === 'emergency' && newLevel !== 2) {
      throw new Error('First approval for emergency requests must be from Hostel Incharge');
    } else if (this.category === 'normal' && newLevel !== 1) {
      throw new Error('First approval for normal requests must be from Floor Incharge');
    }
  }

  // Get last valid approval
  const lastValidApproval = [...existingApprovals]
    .reverse()
    .find(a => a.status === 'approved');

  // Ensure proper sequence
  if (lastValidApproval) {
    const lastLevel = getLevel(lastValidApproval.level);
    
    // Allow same level approvals for current level
    if (newLevel === getLevel(this.currentLevel)) {
      return true;
    }

    // Check sequence - handle emergency requests differently
    if (this.category === 'emergency') {
      // For emergency: hostel-incharge (level 2) can be followed by warden (level 3) or complete
      if (lastLevel === 2 && newLevel === 3) {
        return true; // Valid: hostel-incharge -> warden
      }
    } else {
      // Normal sequence validation for regular requests
      if (newLevel !== lastLevel + 1) {
        throw new Error(
          `Invalid approval sequence: Expected level ${lastLevel + 1}, got ${newLevel}`
        );
      }
    }
  }

  return true;
};

homePermissionRequestSchema.pre('save', function(next) {
  try {
    // Set initial currentLevel based on category for new requests
    if (this.isNew) {
      if (this.category === 'emergency') {
        this.currentLevel = 'hostel-incharge';
        console.log('ðŸš¨ Emergency request - setting currentLevel to hostel-incharge:', this._id);
      } else {
        this.currentLevel = 'floor-incharge';
        console.log('ðŸ“‹ Normal request - setting currentLevel to floor-incharge:', this._id);
      }
    }

    if (this.isModified('approvalFlow') && this.approvalFlow?.length > 0) {
      // Get latest approval
      const latestApproval = this.approvalFlow[this.approvalFlow.length - 1];
      
      // Update approvalFlags and currentLevel/status based on approval
      if (latestApproval.status === 'approved') {
        const level = String(latestApproval.level);
        switch (level) {
          case '1':
          case 'floor-incharge':
            this.approvalFlags.floorIncharge.isApproved = true;
            this.approvalFlags.floorIncharge.timestamp = latestApproval.timestamp || new Date();
            this.approvalFlags.floorIncharge.remarks = latestApproval.remarks || '';
            if (this.currentLevel === 'floor-incharge') {
              this.currentLevel = 'hostel-incharge';
            }
            break;
          case '2':
          case 'hostel-incharge':
            this.approvalFlags.hostelIncharge.isApproved = true;
            this.approvalFlags.hostelIncharge.timestamp = latestApproval.timestamp || new Date();
            this.approvalFlags.hostelIncharge.remarks = latestApproval.remarks || '';
            if (this.currentLevel === 'hostel-incharge') {
              // For emergency requests, directly generate QR code and complete
              if (this.category === 'emergency') {
                this.currentLevel = 'completed';
                this.status = 'approved';
              } else {
                this.currentLevel = 'warden';
              }
            }
            break;
          case '3':
          case 'warden':
            this.approvalFlags.warden.isApproved = true;
            this.approvalFlags.warden.timestamp = latestApproval.timestamp || new Date();
            this.approvalFlags.warden.remarks = latestApproval.remarks || '';
            if (this.currentLevel === 'warden') {
              this.currentLevel = 'completed';
              this.status = 'approved';
            }
            break;
        }
      }
    }
    next();
  } catch (error) {
    next(error);
  }
});

module.exports = mongoose.model('HomePermissionRequest', homePermissionRequestSchema);